# Домашнее задание по уроку 3 "Принципы SOLID"

## Задача 1
Спроектировать абстрактный класс «Car» у которого должны быть свойства: марка, модель, цвет, тип кузова, число колёс, тип топлива, тип коробки передач, объём двигателя; методы: движение, обслуживание, переключение передач, включение фар, включение дворников.

### Решение
Создан абстрактный класс `Cars.Car` с базовыми функциями машины.

## Задача 2
Создать конкретный автомобиль путём наследования класса «Car».

### Решение
Создал автомобиль `toyota` путём наследования класса `Car` и метод `Core.run()` для управления функциями автомобиля: 
```
Toyota toyota = new Toyota("Camry", "blue", "sedan", "petrol", "auto", 4, 2.5);
Core.run(toyota);
```

## Задача 3
Расширить абстрактный класс «Car», добавить метод: подметать улицу. Создать конкретный автомобиль путём наследования класса «Car». Провести проверку принципа SRP.

### Решение
В соответствии с принципом SRP класс `Car` должен заниматься только базовыми методами для всех машин: движение, включение фар, дворников и т.д.  
Для реализации метода уборки улиц я создал класс `StreetCleaner.StreetCleanerCar` и добавил его экземпляр в класс `Cars.Kamaz` через композицию.   
Также создал интерфейс `StreetCleaner.IStreetCleanerCar` для применения в классе `Cars.Kamaz`, чтобы в методе управления машиной `Core.run()` можно было проверять, принадлежит ли машина к типу машин, имеющему функцию уборки улиц.  
```
Kamaz kamaz = new Kamaz("StreetCleaner", "orange", "track", "diesel", "manual", 6, 6);
Core.run(kamaz);
```

## Задача 4
Расширить абстрактный класс «Car», добавить метод: включение противотуманных фар, перевозка груза. Провести проверку принципа OCP.

### Решение
По аналогии с прежним заданием создал класс `FogLights.FogLightsCar` и интерфейс `FogLights.IFogLightsCar`.  
Принцип OCP соблюдён, т.к. в используемых классах новая функциональность вводится путем добавления нового кода, а не изменением уже существующего.  
Для проверки решения используется тот же объект - `kamaz`.  
```
Kamaz kamaz = new Kamaz("StreetCleaner", "orange", "track", "diesel", "manual", 6, 6);
Core.run(kamaz);
```

### Задача 5
Создать конкретный автомобиль путём наследования класса «Car», определить число колёс = 3. Провести проверку принципа LSP.

### Решение
Создал автомобиль `toyota` с числом колёс 3.  
Принцип LSP не нарушается, т.к. наследник спокойно выполняет все фукнции родителя.
```
Toyota toyota = new Toyota("Camry", "blue", "sedan", "petrol", "auto", 3, 2.5);
Core.run(toyota);
```

## Задача 6
Создать конкретный автомобиль путём наследования класса «Car», определить метод «движение» - «полёт». Провести проверку принципа LSP.

### Решение
Поскольку метод движения `move` у нас изначально отвечает только за старт и остановку машины, то в классе `Car`:  
1) создал дополнительное поле `String moveMode` со значением по умолчанию "Движение по земле";
2) создал метод `setMoveMode()` с параметром названия нового типа движения;
3) в переопределении метода `toString()` добавил строку `"Режим движения: "+this.moveMode`.  

В методе управления машиной `Core.run()`:  
1) в "Инструкциях" добавил новую строку:  
Для смены режима движения используйте команду `move <Режим движения>`
2) в блоке, отвечающем за проверку введённых команд, добавил:
```
   if (cmd.length() > 5 && cmd.substring(0, 5).equals("move ")) {
        myCar.setMoveMode(cmd.substring(5));
        continue;
   }
```
Принцип LSP не нарушается, т.к. наследник спокойно выполняет все фукнции родителя.

## Задача 7
Создать интерфейс «Заправочная станция», создать метод: заправка топливом.

### Решение
Создал интерфейс `FuelStation.IFuelStation` с методом `void refuel()`.

## Задача 8
Имплементировать метод интерфейса «Заправочная станция» в конкретный класс «Car».

### Решение
Имплементировал в класс `Cars.Toyota` интерфейс `FuelStation.IFuelStation`, в классе предусмотрел реализацию метода `refuel()`.

## Задача 9
Добавить в интерфейс «Заправочная станция» методы: протирка лобового стекла, протирка фар, протирка зеркал.

### Решение
Добавил в интерфейс `FuelStation.IFuelStation` методы: `cleanFrontGlass()`, `cleanLights()`, `cleanMirrows()`.

## Задача 10
Имплементировать все методы интерфейса «Заправочная станция» в конкретный класс «Car». Провести проверку принципа ISP. Создать дополнительный/е интерфейсы и имплементировать их в конкретный класс «Car». Провести проверку принципа ISP.

### Решение
Предусмотрел реализацию методов `cleanFrontGlass()`, `cleanLights()`, `cleanMirrows()` в классе `Cars.Toyota`.  
Увидел, что не соблюдается принцип ISP, т.к. не всем водителям на заправочных станциях нужны услуги протирки. У нас получается "толстый" интерфейс. Поэтому я выделил под эти три метода новый интерфейс `FuelStation.IFuelStationCleaning()`. В нём можно разместить все три метода, т.к. у всех машин есть лобовое стекло, фары и зеркала и обычно при протирке они все протираются.  
Придумал дополнительный метод "Питания на заправке". Под него создал отдельный интерфейс `FuelStation.IFuelStationFood`, т.к. не все покупают еду на заправках. Имплементировал в класс `Cars.Toyota`, реализовал соответствующий метод `void eatOnFuelStation()`.

## Задача 11
Создать путём наследования класса «Car» два автомобиля: с бензиновым и дизельным двигателями, имплементировать метод «Заправка топливом» интерфейса «Заправочная станция». Реализовать заправку каждого автомобиля подходящим топливом. Провести проверку принципа DIP.

### Решение
Прописал в методе заправки топливом `refuel()` в классах обоих автомобилей - `Toyota` и `Kamaz` - код:
```
System.out.println("Машина "+this.make+" заправилась топливом "+this.fuelType);
```
Принцип DIP не нарушается, т.к. у нас работа классов конкретных автомобилей не зависит от конкретного топлива, т.к. метод заправки использует то топливо, которое было передано при создании экземпляров этих классов.
```
Toyota toyota = new Toyota("Camry", "blue", "sedan", "petrol", "auto", 3, 2.5);
Kamaz kamaz = new Kamaz("StreetCleaner", "orange", "track", "diesel", "manual", 6, 6);

toyota.refuel();
kamaz.refuel();
```